\chapter{C++ Implementation}
%TODO update the content below, migrate commentary, input usage file...

The above transformation have been implemented in C++.  Program \lsti{main.cpp} takes on argument specifying the type of input object.  It reads the description of the object from standard input, and writes the result of the implied transformation to standard output.  If no arguments are supplied, then a \lsti{usage} message is given.  The \lsti{usage} message, which also contains the input format for the objects, is:

\VerbatimInput{../../usage.txt}

The files pertaining to the implementation will be discussed in the following sections, but here is a table showing the include dependencies followed by a short summary of the files. \\

\begin{tabular}{|l|l|}
\hline
file & includes \\
\hline
\filename{linear\_algebra.h} & \\
\filename{fourier\_motzkin.h} & \filename{linear\_algebra.h} \\
\filename{polyhedra.h} &        \filename{fourier\_motzkin.h} \\
\filename{main.cpp} &           \filename{polyhedra.h} \\
\filename{test\_functions.h} &  \filename{linear\_alebra.h} \\
\filename{test.cpp} &           \filename{test\_functions.h}, \filename{polyhedra.h}\\
\hline
\end{tabular}\\

\vspace{1em}

Here is a very brief summary of the files mentioned in the above table, more details are given in sequent sections.

\begin{itemize}
  \item \texttt{linear\_algebra.h}\\
    Types \lsti{Vector} and \lsti{Matrix}, and some basic functionality for them
  \item \texttt{fourier\_motzkin.h} \\
    Fourier Motzkin elimination, \MWT for cones
  \item \texttt{polyhedra.\{cpp,h\}} \\
    Transforms between polytopes and polyhedra, \MWT
  \item \texttt{test\_functions.h} \\
    Types and functions for testing the algorithms, e.g. if an h-polyhedra contains some points
  \item \texttt{test.cpp} \\
    Test cases for functions from \filename{test\_functions.h} and algorithms for \MWT
\end{itemize}

\section{Code}

The relevant code will be displayed with commentary below.  Some of the code relating to C{++} specific technicalities and I/O is ommitted.

\subsection{\filename{linear\_algebra.h}}
The types \lsti{Vector} and \lsti{Vatrix} are used in the representation of polyhedra.  The \lsti{std::valarray} template is used because it has built-in vector-space operations (sum and scaling).  \lsti{std::vector}, is used, however other sequence containers could be used.
\lsttdVecs

The \lsti{class Matrix} implements a subset of what a \textit{C++ Container} should.  It is the primary type for representing polyhedra, and directly represents Cones, as well as H-Polyhedra.  The interface is designed to enforce the following invariant:
\[ \invariant{(\forall \mli{v} \in \mli{vectors})\, \mli{v.size() == d}} \]
  The \textit{factory} function \lsti{read_Matrix} is provided to read a \lsti{Matrix} from an \lsti{istream}.  It is necessary because the value of \lsti{d} can't be known before reading some of the stream.
\lstMatrix

The \lsti{struct VPoly} gather two \lsti{Matrix}s needed to represent a V-Polyhedron.  The \lsti{Matrix U} corresponds to the rays that generate the cone, and the \lsti{Matrix V} corresponds to the points, i.e. 
  \[ \mli{Vpoly vpoly} = \set{p + q \st p \in \cone(\mli{vpoly.U}),\, q \in \conv( \mli{vpoly.V} )} \]
\lstVPoly

The \lsti{class input_error} is thrown to indicate an invalid input to the program, and provide some clue as to why it failed.  Here are two command line examples:
\VerbatimInput{../../bad_usage.txt}

\lstinputerror

\lsti{operator>>} and \lsti{operator<<} implement the input format described in \\\filename{usage.txt}.
\lstissV
\lstossV

\lsti{usage()} outputs the usage message shown above.
\lstusage

\subsection{\filename{linear\_algebra.cpp}}
\lsti{e_k} creates the canonical basis \lsti{Vector} $\e_k \in \R^d$.
\lstek

\lsti{concatentate} takes the \lsti{Vector}s $\mli{l} \in \R^{\mli{l.size()}}$ and $\mli{r} \in \R^{\mli{r.size()}}$ and \lsti{return}s the \lsti{Vector} $(\mli{l,r}) \in \R^{\mli{l.size() + r.size()}}$
\lstconcatenate

\lsti{get_column} \lsti{return}s the \lsti{k}-th column of the \lsti{Matrix M}.  Note that while a \lsti{Matrix} may logically represent either a collection of row or column \lsti{Vector}s, \lsti{get_column} is only used in the function \lsti{transpose}, where this distinction is unimportant.
\lstgetcolumn

\lsti{transpose} \lsti{return}s the transpose of \lsti{Matrix M}.
\lsttranspose

An \lsti{slice} object can be used to conveniently obtain a subset of an \lsti{valarray}.  \lsti{slice_matrix} \lsti{return}s the \lsti{Matrix} obtained by applying the \lsti{slice s} to each \lsti{Vector} of the \lsti{Matrix}.
\lstslicematrix

\subsection{\filename{fourier\_motzkin.h}}

\lsti{Lift} is a function pointer \lsti{typedef} that is used in a generic cone-transformation function.
\lstLift

\subsection{\filename{fourier\_motzkin.cpp}}

A \lsti{slice} object is determined by three fields: \lsti{start}, \lsti{size}, and \lsti{stride}, and implicitly represents all indices of the form:
\[ \sum_{0 \leq k < \mli{size}} \mli{start} + k\cdot\mli{stride} \]
Therefore:
\[ i \in \mli{slice} \Leftrightarrow i - \mli{start} \equiv 0 \mod(\mli{stride}),
                           \quad \mli{start} \leq i \leq \mli{start} + {\mli{stride}}\cdot\mli{size} \]
\lstindexinslice

\lsti{fourier_motzkin} takes a \lsti{Matrix M} and a coordinate \lsti{k} and creates the set which either corresponds to a projection of an H-Cone (without actually doing the projection), or the intersection of a V-Cone with a coordinate-hyperplane.
\lstfouriermotzkin

The lines:
\lstFMEPart
Partition \lsti{M} into logical sets $Z,P,N$ that satisfy the following:\\

\begin{tabular}{|l|l|l|}
  \hline
set & range & property \\
  \hline
  $Z$ & [\lsti{M.begin()}, \lsti{z_end} $)$ & 
      \lsti{it} $\in Z \Leftrightarrow$ \lsti{(*it)[k]} $ = 0$ \\
  \hline
  $P$ & [\lsti{z_end}, \lsti{p_end} ) & 
      \lsti{it} $\in P \Leftrightarrow$ \lsti{(*it)[k]} $ > 0$ \\
  \hline
  $N$ & [\lsti{p_end}, \lsti{M.end()}) & 
      \lsti{it} $\in N \Leftrightarrow$ \lsti{(*it)[k]} $ < 0$ \\
  \hline
\end{tabular}\\

The line:
\lstFMEMove
Moves $Z$ into the result.  The lines:
\lstFMEConvolute
Convolutes the vectors in the way described in Propositions \ref{prop:hconeproj} and \ref{prop:Hintset} (concerning projecting an H-Cone and intersecting a V-Cone with a coordinate-hyperplane), and push them into the result \lsti{Matrix}.  In particular, it creates the sets which correspond to
\[ \Bik B_j - \Bjk B_i \st i \in P,\, j \in N \\ \]

\lsti{sliced_fourier_motzkin} applies \lsti{fourier_motzkin} to \lsti{Matrix M} for each $k \not\in \mli{slice s}$, then slices the resulting \lsti{Matrix} using \lsti{slice_matrix} and \lsti{s}.  This is the realization of the algorithms indicated by the proofs of either direction of the {\MWT} for cones.
\lstslicedfouriermotzkin

When transforming an H-Cone to a V-Cone, it first must be written as a V-Cone of a new matrix, then it is intersected with coordinate-hyperplanes and projected.  Similarly, when a V-Cone is transformed into an H-Cone, it must be written as and H-Cone of a new matrix then projected with coordinate-projections.  The transformations are described in \eqref{eq:Alift} and \eqref{eq:Ulift}, and summarized here:
\[
  A \to \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*} \quad
  U \to \begin{pmatrix*}[r] \0 & I & -I \\ I & A & -A \end{pmatrix*}
\]
Note that the tranformation of $U$ can be written:
\[ U \to \begin{pmatrix*}[r] \0 & I \\ I & A \\ -I & -A \end{pmatrix*}^T \]

Remembering that a \lsti{Matrix} is either a collection of row \textit{or} column \lsti{Vector}s, it is not surprising that these two transformations can be written as one function of a \lsti{Matrix} and some coefficients.  In \lsti{generalizedlift}, the coefficients are given as an \lsti{array<double, 5> C}, so the overall transformation can be illustrated as:
\newcommand{\CA}[1]{\mli{C[#1]}}
\[ \mli{Matrix M} \to 
    \begin{pmatrix*}[r] 
      \0 & \CA{0}I \\ 
      \CA{1}I & \CA{2}\mli{M} \\ 
      \CA{3}I & \CA{4}\mli{M} 
    \end{pmatrix*} \]
Where \lsti{Matrix M} is a collection of row \lsti{Vector}s, or
\[ \mli{Matrix M} \to 
  \begin{pmatrix*}[r] 
    \0 & \CA{1}I & \CA{3}I \\ 
    \CA{0}I & \CA{2}\mli{M} & \CA{4}\mli{M} 
  \end{pmatrix*} \]
Where \lsti{Matrix M} is a collection of column \lsti{Vector}s.
\lstgeneralizedlift

\lsti{lift_vcone} and \lsti{lift_hcone} implement the appropriate transformation using \lsti{generalized_lift} and providing the appropriate coefficients in \\
\lsti{array<double, 5> C}.
\lstliftvcone
\lstlifthcone

\lsti{cone_transform} consolidates the logic of the V-Cone $\to$ H-Cone and H-Cone $\to$ V-Cone transformations by accepting a \lsti{Matrix cone} and a \lsti{Lift}.
\lstconetransform

\lsti{vcone_to_hcone} and \lsti{hcone_to_vcone} specialize \lsti{cone_transform} by providing the appropriate \lsti{Lift}.
\lstvconetohcone
\lsthconetovcone

\subsection{\filename{polyhedra.cpp}}

\lsti{hpoly_to_hcone} and \lsti{hcone_to_hpoly} implement the \lsti{Matrix} transforms:
\[ \mli{hpoly_to_hcone}: (A|b) \to (-b|A),\quad \mli{hcone_to_hpoly} : (-b|A) \to (A|b) \]
These very simple transforms are done with the \lsti{cshift} function, which ``circularly shifts'' the elements of a \lsti{Vector} (provided as part of the interface to \lsti{valarray}).
\lsthpolytohcone
\lsthconetohpoly

\lsti{vpoly_to_vcone} implements the \lsti{VPoly} transform:
\[ \mli{vpoly} \to 
    \begin{pmatrix} 
      \0 & \vec{1} \\ \mli{vpoly.U} & \mli{vpoly.V} 
    \end{pmatrix} \]
\lstvpolytovcone

\lsti{normalized_P} calculates the $V$ in \eqref{eq:cvtopv}.  Let $\Pi$ is the identity matrix with the $0$-th row deleted, and $P = \set{\u \in U : u_0 > 0}$. then this is the result of:
  \[ \Pi(\cone(P) \cap \set{x_0 = 1}) \]
\lstnormalizedP

\lsti{vcone_to_vpoly} implements the full tranformation in \eqref{eq:cvtopv}.
\lstvconetovpoly

\lsti{hpoly_to_vpoly} and \lsti{vpoly_to_hpoly} implement the complete transformations promised by the file.
\lsthpolytovpoly
\lstvpolytohpoly

\section{Testing}

In the next sections, the methods used for testing the program described above will be discussed.

\subsection{Testing H-Cone $\to$ V-Cone}
Suppose we have an H-Cone $C_H = \set{A\x\leq\0}$, and would like to test if a V-Cone $\cone(V')$ represents the same set.  It's easy to check if
  \[ (\forall v' \in V') A\v'\leq\0 \Rightarrow \cone(V') \subseteq C_H \]
It's not clear what to do to check if $C_H \subseteq \cone(V')$.  Suppose we had a set $V$, and we knew that $C_H = \cone(V)$, and that $\cone(V) = \cone(V') \Rightarrow V \subseteq V'$.  Then we'd have the following situation:
\begin{alignat*}{2}
  &(\forall \v'\in V') A\v'\leq\0 \;&\Rightarrow&\; \cone(V') \subseteq C_H \\
  &V \subseteq V'                 \;&\Rightarrow&\; C_H \subseteq \cone(V') \\
  &\cone(V') = C_H                \;&\Rightarrow&\; V \subseteq V' \\
  &\cone(V') = C_H                \;&\Rightarrow&\; (\forall \v'\in V') A\v'\leq\0
\end{alignat*}
Therefore, we have
\[ C_H = \cone(V') \Leftrightarrow \left[ V \subseteq V',\;(\forall \v'\in V') A\v'\leq\0 \right] \]  The problem is now to come up with such a set $V$.  We will need to relax the requirements on $V$ a little bit, but not in a way that reduces its utility.  The set is desribed in the next proposition, but first we introduce the notion of equivalence vectors:

\begin{Def}[vector equivalence]
  Let $\u,\v \in \R^d$, and suppose that $\u/\norm{\u} = \v/\norm{\v}$.  Then say that $\u,\v$ are equivalent, and write:
  \[ \u \simeq \v \]
\end{Def}

\begin{Def}[Extreme]
  Let $V \in \R^{d\times n}$, if no member of $V$ is a positive linear combination of other elements of $V$ then $V$ is called \textit{extreme}.
\end{Def}


\begin{Prop}{\label{prop:minrays}
  Let $V \in \R^{d\times n}$ be extreme.  Then
  \[ \cone(V) = \cone(V') \Rightarrow (\forall \v \in V)(\exists \v'\in V') 
                            : \v \simeq \v' \]
} \end{Prop}

\begin{proof}
Let $\v \in V$, so that $\v = V\e_k$.  Since $\cone(V) = \cone(V')$, there exists a matrix $A$ with all non-negative entries such that $V' = VA$.  There is also a non-negative $b$ such that $\v = V'b$.  Then $\v = (VA)b = V(A\b)$.  Since $A$ and $b$ contain only non-negative entries, so does $A\b$.  Since $\v$ is not a non-negative combination of other vectors from $V$, $A\b$ must be the basis vector $\e_k$.  Then if $i \neq k$, $\e_i^T(A\b) = 0$, or $(\e_i^TA)b = \sum_j A_i^j b_j = 0$.  Since $A_i^j, b_j \geq 0$, we have:
\begin{alignat*}{3}
  (\forall i \neq k)&\quad&A_i^j > 0 \;&\Rightarrow&\; b_j = 0 \\
  (\forall i \neq k)&\quad&b_j > 0   \;&\Rightarrow&\; A_i^j = 0
\end{alignat*}
Furthermore, we have $\ip{A_k}{b} = 1$, so for some $l$, $A_i^l,b_l > 0$.  Then, 
\[ (\forall i \neq k)\quad A_i^l = 0 \]
Now let $\b'=\e_l/A_k^l$.  Then it immediately follows that $\ip{A_k}{\b'} = 1$.  Also,
\[ (\forall i \neq k)\quad A_i^l = 0 \quad \Rightarrow\quad \ip{A_i}{b'} = A_i^l/A_k^l = 0\]
We conclude that $A\b' = \e_k = A\b$, and that $\v = V(A\b) = V(A\b') = (VA)\b' = U(\e_l/A_k^l)$.  If $\v' = U\e_l$, that is $\v'$ is the $l$-th vector of $U$, then $\v = \v'/A_k^l$, or 
\[ \v/\norm{\v} = (\v'/A_k^l)/\norm{\v'/A_k^l} = \v'/\norm{\v'} \]
So $\v \simeq \v'$.
\end{proof}

Let's denote $(\forall \v \in V)(\exists \v'\in V') : \v \simeq \v'$ as $V \sqsubseteq V'$.  Then, considering the discussion before the proposition, we have the following result.  Say $V \in \R^{d\times n}$ is extreme.  Also suppose that $C_V = \cone(V) = \set{\x\st A\x\leq\0}$.  Then
\[ C_V = \cone(V') \quad\Leftrightarrow\quad 
   (\forall \v'\in V')A\v'\leq\0,\; V \sqsubseteq V' \]

We now have a method for testing the program.  First, we hand-craft an H-Cone $\set{\x\st A\x\leq\0}$ based on some extreme set $V$, then run our program to get a set $V'$, with the alleged property that $\cone(V') = \set{\x\st A\x\leq\0}$.  If we confirm that $\forall \v'\in V', A\v'\leq 0$ and $V \sqsubseteq V'$, then our program has succeeded.

\subsection{Farkas Lemma}
The procedure for the other direction is \textit{almost} identical, but there is a slight catch.  Call a set of row vectors \textbf{extreme} if no row is a non-negative combination of the other.  We would be able to use proposition \ref{prop:minrays} to say something similar about an extreme set of row vectors $A$, if we could say that:

\begin{Prop}\label{prop:ddcones}
  \[ \set{\x\st A\x\leq\0} = \set{\x\st A'\x\leq\0} \Leftrightarrow \cone(A^T) = \cone(A'^T) \]
\end{Prop}


To prove this proposition, we use the Farkas Lemma:

\begin{Prop}[The Farkas Lemma]
  Let $U \in \R^{d\times n}$.  Precisely one of the following is true:
  \[ (\exists \t \geq \0) : \x = U\t \]
  \[ (\exists \y) : U^T\y \leq 0,\; \ip{\x}{\y} > 0 \]
\end{Prop}

\begin{proof}  That both can't be true can be seen by:
  \[ \x = U\t \quad\Rightarrow\quad \y^T\x = \y^T U\t \quad\Rightarrow\quad 0 \neq 0 \]
To see that at least one is true we must reconsider the process of converting a V-Cone to an H-Cone.  First, we lift the V-Cone $\cone(U)$ into the following form:
  \[ A = \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*}  \]
In the proof of the transformation, we use proposition \ref{prop:hconeproj} to transform that matrix $A$.  The remark \ref{rem:fm} after the proof of the proposition promises a sequence of matrices $Y_{d+1}, \dots, Y_{d+n}$ satisfying certain properties.  Let $Y = Y_{d+n}Y_{d+(n-1)}\dots Y_{d+1}$, then it can be said of $Y$:
\begin{enumerate}
  \item Every element of $Y$ is non-negative.
  \item $Y$ is finite.
  \item The last $n$ columns of $YA$ is $\0$.
  \item \((\exists t_{d+1},\dots,t_{d+n})A(\x + \sum_{i=d+1}^{d+n} t_i\e_i) \leq \0 
        \Leftrightarrow (YA)\x \leq \0 \)
\end{enumerate}
Note that here $\x \in \R^{d+n}$.  $A$ has three blocks of rows, which can be labeled with $Z,P,N$ in a fairly obvious way.  Then, $Y$ can be broken up into three blocks of columns, so that
\[ Y = (Y_Z \; Y_P \; Y_N) \]
Where each of $Y_Z,Y_P,Y_N \geq \0$.  Consolidating what is known about $A$ and $Y$,
\[ YA = (Y_Z \; Y_P \; Y_N) \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*}  
      = (Y' \; \0) \]
Here, we have let $Y' = Y_P - Y_N$.  Then it follows that
\[ \0 = -Y_Z - Y_P(U) + Y_N(U) = -Y_Z - Y'(U) \;\Rightarrow\; Y_Z = - Y'U 
          \;\Rightarrow\; Y'U \leq \0 \]
Then it holds that, for any row $\y' \in Y'$:
\begin{equation}\label{eq:flneg}
  \y'U \leq \0
\end{equation}
We also have
\begin{equation}\label{eq:flconst}
  (\exists \t) : A \xt \leq \0 \Leftrightarrow (YA)\xt = (Y'\;\0)\xt = Y'\x \leq \0  
\end{equation}
Note that here $\x \in \R^d$.  So, if given some $\x$, the left side of \eqref{eq:flconst} is not satisfied, then neither is the right, and there must be some row $\y' \in Y'$ such that the following holds:
\begin{equation}\label{eq:flconstbrk} \ip{\y'}{\x} > 0 \end{equation}
Furthermore, by the way $A$ is constructed, 
\begin{equation}\label{eq:flcone}
  (\exists \t) : A \xt \leq \0 \Leftrightarrow (\exists \t\geq\0)\; \x = U\t
\end{equation}
Then we conclude that, if the right side of \eqref{eq:flcone} fails, then there is a vector $\y' \in Y'$ satisfying \eqref{eq:flneg} and \eqref{eq:flconstbrk}.
\end{proof}

\subsection{Testing V-Cone $\to$ H-Cone}

Now we can prove proposition \ref{prop:ddcones}:
  \[ \set{\x\st A\x\leq\0} = \set{\x\st A'\x\leq\0} \Leftrightarrow \cone(A^T) = \cone(A'^T) \]
\begin{proof}
First suppose that $\cone(A^T) = \cone(A'^T)$.  Then there exists a non-negative matrix $B$ such that $A'^T = A^TB$.  Then $A\x \leq \0 \Rightarrow B^TA\x\leq \0 \Rightarrow A'\x\leq\0$.  Precisely the same reasoning shows that $A'\x\leq\0 \Rightarrow A\x\leq\0$, and we conclude that $\cone(A^T) = \cone(A'^T) \Rightarrow \set{\x\st A\x\leq\0} = \set{\x\st A'\x\leq\0}$.

Next suppose that $\cone(A^T) \neq \cone(A'^T)$, that is, let $\z \in \cone(A), \z \not\in\cone(A')$.  We must show that $\set{\x\st A\x\leq\0} \neq \set{\x\st A'\x\leq\0}$.  By the Farkas Lemma, we have a $\y$ such that $\ip{\y}{\z} > 0,\; A'\y \leq \0$.  Clearly this means that $\y \in \set{\x\st A'\x\leq\0}$.  Since $\z \in \cone(A)$, there is some $(\t \geq \0): \z^T = \t^T A$.  Then if $A\y\leq\0$, we would have $\ip{\y}{\z} = \t^T A\y \leq 0 < \ip{\y}{\z}$, a contradiction.  So we conclude that $\y\not\in\set{\x\st A\x\leq\0}$.
\end{proof}

\paragraph{The Test}
\textit{Finally}, we can make a test for the transformation from V-Cone to H-Cone.  Let $A$ be an \textit{extreme} set of row vectors.  Then clearly $A^T$ is an extreme set of column vectors, and we can use propositions \ref{prop:minrays} and \ref{prop:ddcones} to say that 
\[ \HC{A} = \HC{A'} \Leftrightarrow \cone(A^T) = \cone(A'^T) \Rightarrow A^T \sqsubseteq A'^T \]
Given the last implication, we can also write $A \sqsubseteq A'$, where we are now considering $A$ and $A'$ as sets of row vectors as opposed to column vectors.

Now, as before, we suppose that we have a set $V$ and $A$, where $A$ is extreme, and we know that $C := \cone(V) = \HC{A}$.  We run our program on $V$ and get a new set $A'$, and would like to know if $C = \HC{A'}$.  We have the following situation:
\begin{alignat*}{2}
  &C = \HC{A'}    \;&\Rightarrow&\; A \sqsubseteq A' \\
  &C = \HC{A'}    \;&\Rightarrow&\; (\forall \v\in V) A'\v \leq \0 \\
  &A \sqsubseteq A' \;&\Rightarrow&\; \HC{A'} \subseteq C \\
  &(\forall \v\in V) A'\v \leq \0  \;&\Rightarrow&\; C \subseteq \HC{A'} 
\end{alignat*}
So we can conclude that
\[ C = \HC{A'} \quad\Leftrightarrow\quad 
   (\forall \v\in V)A'\v\leq\0,\; A \sqsubseteq A' \]

\subsection{\filename{test\_functions.h}}

The following types are defined for running tests of the different algorithms.  They are expected to be given a descriptive name, the object on which the test will be run, and a \lsti{key} with which the result of the test will be compared.  The \list{key} object is one of the objects described above.
\lsthconetestcasea
\lstvconetestcasea
\lsthpolytestcaseb
\lstvpolytestcaseb

\subsection{\filename{test\_functions.cpp}}

The dot-product and norm (in terms of dot product).
\lstoperator
\lstnorm

\lsti{approximately_zero} is used during tests to avoid issues involving floating point rounding errors.  For example, \lsti{1/6.0 * 2.5 - 5/12.0 == 0} will give \lsti{false}, while \lsti{approximately_zero(1/6.0 * 2.5 - 5/12.0)} will return \lsti{true}.  Test cases are used where intermediate calculations don't depend on such high accuracy, and these discrepencies can be ignored.

\lsti{approximately_zero(c) == true} will be denoted $\mli{c} \approx 0$.
\lstapproximatelyzeroa

%Tests $\mli{c} < 0 \lor \mli{c} \approx 0$.
Tests $c < 0 \lor c \approx 0$.
\lstapproximatelyltzero

%Tests $\norm{\mli{v}} \approx 0$.  This will be denoted $\mli{v} \approx \0$.
Tests $\norm{\v} \approx 0$.  This will be denoted $\v \approx \0$.
\lstapproximatelyzerob

%Tests $\mli{l}/\norm{\mli{l}} - \mli{r}/\norm{\mli{r}} \approx \0 $.  This will be denoted $\mli{l} \simeq \mli{r}$.
Tests $\u/\norm{\u} - \v/\norm{\v} \approx \0 $.  This will be denoted $\u \simeq \v$.
\lstisequivalent

%Tests $\mli{l} - \mli{r} \approx \0$.  This will be denoted $\mli{l} \approx \mli{r}$.
Tests $\u - \v \approx \0$.  This will be denoted $\u \approx \v$.
\lstisequal

%Tests $(\exists \mli{u} \in \mli{Matrix M}) \st \mli{v} \simeq \mli{u}$.
Tests $(\exists \u \in U) \st \v \simeq \u$.
\lsthasequivalentmember

%Tests $(\exists \mli{u} \in \mli{Matrix M}) \st \mli{v} \approx \mli{u}$.
Tests $(\exists \u \in U) \st \v \approx \u$.
\lsthasequalmember

%Tests $(\forall \mli{ray} \in \mli{Matrix vcone}) (\exists \mli{g} \in \mli{Matrix generators}) \st \mli{v} \simeq \mli{u}$.
Tests $(\forall v \in V)(\exists \u \in U) \st \v \simeq \u$.  This will be denoted $V \sqsubseteq U$.
\lstsubsetmodeq

%Tests $(\forall \mli{ray} \in \mli{Matrix vcone}) (\exists \mli{g} \in \mli{Matrix generators}) \st \mli{v} \approx \mli{u}$.
Tests $(\forall v \in V)(\exists \u \in U) \st \v \approx \u$.  This will be denoted $V \subseteq U$.
\lstsubset

Given a \mli{Vector constraint} and \mli{Vector ray}, tests if \\
\lsti{approximately_lt_zero(ray * constraint)}.  Note that if the constraint is of the form $\ip{A_i}{\v} \leq b$ for some value $b$, then this still works, because the dot product function only takes the first $d$ values of each vector.
\lstraysatisfieda

%Test $(\forall \mli{cv} \in \mli{Matrix constraints})\,\mli{ray_satisfied(ray, cv)}$
Test $A\v \leq \0$
\lstraysatisfiedb

%Test 
%\begin{align*}
  %&(\forall \mli{ray} \in \mli{Matrix rays})(\forall \mli{cv} \in \mli{Matrix constraints})\\
  %&\quad\mli{ray_satisfied(ray, cv)}
%\end{align*}

Test $(\forall \v) A\v \leq \0$
\lstrayssatisfied

Test $\ip{A_i}{\v} \leq b_i$
\lstvecsatisfieda

Test $A\v \leq \b$
\lstvecsatisfiedb

Test $(\forall \v) A\v \leq \b$
\lstvecssatisfied

Given an H-Cone $C_H = \set{\x\st A\x\leq\0} = \cone(U)$ where $U$ is minimal, and an alternative representation $U'$, determines if $C_H = \cone(U')$.

Similarly, given a V-Cone $C_U = \cone(U) = \set{\x\st A\x\leq\0}$ where $A$ is minimal, and an alternative representation $A'$, determines if \\
$C_U = \set{\x\st A'\x\leq\0}$.
\lstequivalentconerep

Given an H-Polytope $P_H = \set{\x\st A\x\leq\b} = \cone(U) + \conv(V)$ where $U$ and $V$ are minimal, and an alternative representation $(U',V')$, determines if $P_H = \cone(U') + \conv(V')$.
\lstequivalenthpolyrep

Given a V-Polytope $P_V = \cone(U) + \conv(V) = \set{\x\st A\x\leq\b}$ where $A$ is minimal, and an alternative representation $A'$, determines if $P_V = \set{\x\st A'\x\leq\0}$.
\lstequivalentvpolyrep

%\lsthconetestcaseb
%\lstvconetestcaseb
%\lsthpolytestcasea
%\lstvpolytestcasea


