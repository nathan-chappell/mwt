\chapter{C++ Implementation}
%TODO update the content below, migrate commentary, input usage file...

The above transformations have been implemented in C++.  Program \lsti{main.cpp} takes one argument specifying the type of input object.  It reads the description of the object from standard input, and writes the result of the implied transformation to standard output.  If no arguments are supplied, then a \lsti{usage} message is given.  The \lsti{usage} message, which also contains the input format for the objects, is:

\VerbatimInput{../../usage.txt}

The files pertaining to the implementation will be discussed in the following sections, but here is a table showing the include dependencies followed by a short summary of the files. \\

\begin{tabular}{|l|l|}
	\hline
	file                          & includes                                             \\
	\hline
	\filename{linear\_algebra.h}  &                                                      \\
	\filename{fourier\_motzkin.h} & \filename{linear\_algebra.h}                         \\
	\filename{polyhedra.h}        & \filename{fourier\_motzkin.h}                        \\
	\filename{main.cpp}           & \filename{polyhedra.h}                               \\
	\filename{test\_functions.h}  & \filename{linear\_alebra.h}                          \\
	\filename{test.cpp}           & \filename{test\_functions.h}, \filename{polyhedra.h} \\
	\hline
\end{tabular}\\

\vspace{1em}

Here is a very brief summary of the files mentioned in the above table, more details are given in sequent sections.

\begin{itemize}
	\item \texttt{linear\_algebra.h} \\
	      Types \lsti{Vector} and \lsti{Matrix}, and some basic functionality for them
	\item \texttt{fourier\_motzkin.h} \\
	      Fourier Motzkin elimination, {\MWT} for cones
	\item \texttt{polyhedra.\{cpp,h\} } \\
	      Transforms between polytopes and polyhedra, {\MWT}
	\item \texttt{test\_functions.h} \\
	      Types and functions for testing the algorithms
	\item \texttt{test.cpp} \\
	      Test cases for the algorithms and the functions from \filename{test\_functions.h}
\end{itemize}

\section{Code}

The relevant code will be displayed with commentary below.  Some of the code relating to C{++} specific technicalities and I/O is ommitted.

\subsection{\filename{linear\_algebra.h}}
The types \lsti{Vector} and \lsti{Vectors} are used in the representation of polyhedra.  The \lsti{std::valarray} template is used because it has built-in vector-space operations (sum and scaling).  \lsti{std::vector}, is used as a container of \lsti{Vector}s, however other containers could be used.
\lsttdVecs

The \lsti{class Matrix} implements a subset of what a \textit{C++ Container} should.  It is the primary type for representing polyhedra, and directly represents Cones, as well as H-Polyhedra.  The interface is designed to enforce the following invariant:
\[ (\forall \mli{v} \in \mli{vectors})\, \mli{v.size() == d} \]
The \textit{factory} function \lsti{read_Matrix} is provided to read a \lsti{Matrix} from an \lsti{istream}.  It is necessary because the value of \lsti{d} can't be known before reading some of the stream.
\lstMatrix

The \lsti{struct VPoly} gather two \lsti{Matrix}s needed to represent a V-Polyhedron.  The \lsti{Matrix U} corresponds to the rays that generate the cone, and the \lsti{Matrix V} corresponds to the points, i.e.
\[ \mli{vpoly} = \cone(\mli{vpoly.U}) + \conv(\mli{vpoly.V}) \]
\lstVPoly

The \lsti{class input_error} is thrown to indicate an invalid input to the program, and provide some clue as to why it failed.  Here are two command line examples:
\VerbatimInput{../../bad_usage.txt}

\lstinputerror

\lsti{operator>>} and \lsti{operator<<} implement the input format described in \\\filename{usage.txt}.
\lstissV
\lstossV

\lsti{usage()} outputs the usage message shown above.
\lstusage

\subsection{\filename{linear\_algebra.cpp}}
\lsti{e_k} creates the canonical basis \lsti{Vector} $\e_k \in \R^d$.
\lstek

\lsti{concatentate} takes the \lsti{Vector}s $\mli{l} \in \R^{\mli{l.size()}}$ and $\mli{r} \in \R^{\mli{r.size()}}$ and \lsti{return}s the \lsti{Vector} $(\mli{l,r}) \in \R^{\mli{l.size() + r.size()}}$
\lstconcatenate

\lsti{get_column} \lsti{return}s the \lsti{k}-th column of the \lsti{Matrix M}.  Note that while a \lsti{Matrix} may logically represent either a collection of row or column \lsti{Vector}s, \lsti{get_column} is only used in the function \lsti{transpose}, where this distinction is unimportant.
\lstgetcolumn

\lsti{transpose} \lsti{return}s the transpose of \lsti{Matrix M}.
\lsttranspose

A \lsti{slice} object can be used to conveniently obtain a subset of a \lsti{valarray}.  \lsti{slice_matrix} \lsti{return}s the \lsti{Matrix} obtained by applying the \lsti{slice s} to each \lsti{Vector} of the \lsti{Matrix}.
\lstslicematrix

\subsection{\filename{fourier\_motzkin.h}}

\lsti{Lift} is a function pointer \lsti{typedef} that is used in a generic cone-transformation function.
\lstLift

\subsection{\filename{fourier\_motzkin.cpp}}

A \lsti{slice} object is determined by three fields: \lsti{start}, \lsti{size}, and \lsti{stride}, and implicitly represents all indices of the form:
\[ \sum_{0 \leq k < \mli{size}} \mli{start} + k\cdot\mli{stride} \]
Therefore:
\[ i \in \mli{slice} \Leftrightarrow i - \mli{start} \equiv 0 \mod(\mli{stride}),
	\quad \mli{start} \leq i \leq \mli{start} + {\mli{stride}}\cdot\mli{size} \]
\lstindexinslice

\lsti{fourier_motzkin} takes a \lsti{Matrix M} and a coordinate \lsti{k} and creates the set which either corresponds to a projection of an H-Cone (without actually doing the projection), or the intersection of a V-Cone with a coordinate-hyperplane.
\lstfouriermotzkin

The lines:
\lstFMEPart
Partition \lsti{M} into logical sets $Z,P,N$ that satisfy the following:\\

\begin{tabular}{|l|l|l|}
	\hline
	set & range                               & property     \\
	\hline
	$Z$ & [\lsti{M.begin()}, \lsti{z_end} $)$ &
	\lsti{it} $\in Z \Leftrightarrow$ \lsti{(*it)[k]} $ = 0$ \\
	\hline
	$P$ & [\lsti{z_end}, \lsti{p_end} )       &
	\lsti{it} $\in P \Leftrightarrow$ \lsti{(*it)[k]} $ > 0$ \\
	\hline
	$N$ & [\lsti{p_end}, \lsti{M.end()})      &
	\lsti{it} $\in N \Leftrightarrow$ \lsti{(*it)[k]} $ < 0$ \\
	\hline
\end{tabular}\\

The line:
\lstFMEMove
Moves $Z$ into the result.  The lines:
\lstFMEConvolute
Convolutes the vectors in the way described in Propositions \ref{prop:hconeproj} and \ref{prop:Hintset} (concerning projecting an H-Cone and intersecting a V-Cone with a coordinate-hyperplane), and push them into the result \lsti{Matrix}.  In particular, it creates the sets which correspond to
\[ \Bik B_j - \Bjk B_i \st i \in P,\, j \in N \\ \]

\lsti{sliced_fourier_motzkin} applies \lsti{fourier_motzkin} to \lsti{Matrix M} for each $k \not\in \mli{slice s}$, then slices the resulting \lsti{Matrix} using \lsti{slice_matrix} and \lsti{s}.  This is the realization of the algorithms indicated by the proofs of either direction of the {\MWT} for cones.
\lstslicedfouriermotzkin

When transforming an H-Cone to a V-Cone, it first must be written as a V-Cone of a new matrix, then it is intersected with coordinate-hyperplanes and projected.  Similarly, when a V-Cone is transformed into an H-Cone, it must be written as and H-Cone of a new matrix then projected with coordinate-projections.  The transformations are described in \eqref{eq:Alift} and \eqref{eq:Ulift}, and summarized here:
\[
	A \to \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*} \quad
	U \to \begin{pmatrix*}[r] \0 & I & -I \\ I & A & -A \end{pmatrix*}
\]
Note that the tranformation of $U$ can be written:
\[ U \to \begin{pmatrix*}[r] \0 & I \\ I & A \\ -I & -A \end{pmatrix*}^T \]

Remembering that a \lsti{Matrix} is either a collection of row \textit{or} column \lsti{Vector}s, it is not surprising that these two transformations can be written as one function of a \lsti{Matrix} and some coefficients.  In \lsti{generalizedlift}, the coefficients are given as an \lsti{array<double, 5> C}, so the overall transformation can be illustrated as:
\newcommand{\CA}[1]{\mli{C[#1]}}
\[ \mli{Matrix M} \to
	\begin{pmatrix*}[r]
		\0 & \CA{0}I \\
		\CA{1}I & \CA{2}\mli{M} \\
		\CA{3}I & \CA{4}\mli{M}
	\end{pmatrix*} \]
Where \lsti{Matrix M} is a collection of row \lsti{Vector}s, or
\[ \mli{Matrix M} \to
	\begin{pmatrix*}[r]
		\0 & \CA{1}I & \CA{3}I \\
		\CA{0}I & \CA{2}\mli{M} & \CA{4}\mli{M}
	\end{pmatrix*} \]
Where \lsti{Matrix M} is a collection of column \lsti{Vector}s.
\lstgeneralizedlift

\lsti{lift_vcone} and \lsti{lift_hcone} implement the appropriate transformation using \lsti{generalized_lift} and providing the appropriate coefficients in \\
\lsti{array<double, 5> C}.
\lstliftvcone
\lstlifthcone

\lsti{cone_transform} consolidates the logic of the V-Cone $\to$ H-Cone and H-Cone $\to$ V-Cone transformations by accepting a \lsti{Matrix cone} and a \lsti{Lift}.
\lstconetransform

\lsti{vcone_to_hcone} and \lsti{hcone_to_vcone} specialize \lsti{cone_transform} by providing the appropriate \lsti{Lift}.
\lstvconetohcone
\lsthconetovcone

\subsection{\filename{polyhedra.cpp}}

\lsti{hpoly_to_hcone} and \lsti{hcone_to_hpoly} implement the \lsti{Matrix} transforms:
\[ \mli{hpoly_to_hcone}: (A|b) \to (-b|A),\quad \mli{hcone_to_hpoly} : (-b|A) \to (A|b) \]
These very simple transforms are done with the \lsti{cshift} function, which ``circularly shifts'' the elements of a \lsti{Vector} (provided as part of the interface to \lsti{valarray}).
\lsthpolytohcone
\lsthconetohpoly

\lsti{vpoly_to_vcone} implements the \lsti{VPoly} transform:
\[ \mli{vpoly} \to
	\begin{pmatrix}
		\0 & \vec{1} \\ \mli{vpoly.U} & \mli{vpoly.V}
	\end{pmatrix} \]
\lstvpolytovcone

\lsti{normalized_P} calculates the $V$ in \eqref{eq:cvtopv}.  Let $\Pi$ is the identity matrix with the $0$-th row deleted, and $P = \set{\u \in U : u_0 > 0}$. then this is the result of:
\[ \Pi(\cone(P) \cap \set{x_0 = 1}) \]
\lstnormalizedP

\lsti{vcone_to_vpoly} implements the full tranformation in \eqref{eq:cvtopv}.
\lstvconetovpoly

\lsti{hpoly_to_vpoly} and \lsti{vpoly_to_hpoly} implement the complete transformations promised by the file.
\lsthpolytovpoly
\lstvpolytohpoly

\section{Testing}

In the next sections, the methods used for testing the program described above will be discussed.

\subsection{Testing H-Cone $\to$ V-Cone}
Suppose we have an H-Cone $C_H = \set{A\x\leq\0}$, and would like to test if a V-Cone $\cone(V')$ represents the same set.  It's easy to check if
\[ (\forall v' \in V') A\v'\leq\0 \Rightarrow \cone(V') \subseteq C_H \]
It's not clear what to do to check if $C_H \subseteq \cone(V')$.  Suppose we had a set $V$, and we knew that $C_H = \cone(V)$, and that $\cone(V) = \cone(V') \Rightarrow V \subseteq V'$.  Then we'd have the following situation:
\begin{alignat*}{2}
	 & (\forall \v'\in V') A\v'\leq\0 \; & \Rightarrow & \; \cone(V') \subseteq C_H        \\
	 & V \subseteq V'                 \; & \Rightarrow & \; C_H \subseteq \cone(V')        \\
	 & \cone(V') = C_H                \; & \Rightarrow & \; V \subseteq V'                 \\
	 & \cone(V') = C_H                \; & \Rightarrow & \; (\forall \v'\in V') A\v'\leq\0
\end{alignat*}
Therefore, we have
\[ C_H = \cone(V') \Leftrightarrow \left[ V \subseteq V',\;(\forall \v'\in V') A\v'\leq\0 \right] \]  The problem is now to come up with such a set $V$.  We will need to relax the requirements on $V$ a little bit, but not in a way that reduces its utility.  The set is desribed in the next proposition, but first we introduce the notion of equivalence vectors:

\begin{Def}[vector equivalence]
	Let $\u,\v \in \R^d$, and suppose that $\u/\norm{\u} = \v/\norm{\v}$.  Then say that $\u,\v$ are equivalent, and write:
	\[ \u \simeq \v \]
\end{Def}

\begin{Def}[Extreme]
	Let $V \in \R^{d\times n}$, if no member of $V$ is a positive linear combination of other elements of $V$ then $V$ is called \textit{extreme}.
\end{Def}


\begin{Prop}{\label{prop:minrays}
		Let $V \in \R^{d\times n}$ be extreme.  Then
		\[ \cone(V) = \cone(V') \Rightarrow (\forall \v \in V)(\exists \v'\in V')
			: \v \simeq \v' \]
	} \end{Prop}

\begin{proof}
	Let $\v \in V$, so that $\v = V\e_k$.  Since $\cone(V) = \cone(V')$, there exists a matrix $A$ with all non-negative entries such that $V' = VA$.  There is also a non-negative $b$ such that $\v = V'b$.  Then $\v = (VA)b = V(A\b)$.  Since $A$ and $b$ contain only non-negative entries, so does $A\b$.  Since $\v$ is not a non-negative combination of other vectors from $V$, $A\b$ must be the basis vector $\e_k$.  Then if $i \neq k$, $\e_i^T(A\b) = 0$, or $(\e_i^TA)b = \sum_j A_i^j b_j = 0$.  Since $A_i^j, b_j \geq 0$, we have:
	\begin{alignat*}{3}
		(\forall i \neq k) & \quad & A_i^j > 0 \; & \Rightarrow & \; b_j = 0   \\
		(\forall i \neq k) & \quad & b_j > 0   \; & \Rightarrow & \; A_i^j = 0
	\end{alignat*}
	Furthermore, we have $\ip{A_k}{b} = 1$, so for some $l$, $A_i^l,b_l > 0$.  Then,
	\[ (\forall i \neq k)\quad A_i^l = 0 \]
	Now let $\b'=\e_l/A_k^l$.  Then it immediately follows that $\ip{A_k}{\b'} = 1$.  Also,
	\[ (\forall i \neq k)\quad A_i^l = 0 \quad \Rightarrow\quad \ip{A_i}{b'} = A_i^l/A_k^l = 0\]
	We conclude that $A\b' = \e_k = A\b$, and that $\v = V(A\b) = V(A\b') = (VA)\b' = U(\e_l/A_k^l)$.  If $\v' = U\e_l$, that is $\v'$ is the $l$-th vector of $U$, then $\v = \v'/A_k^l$, or
	\[ \v/\norm{\v} = (\v'/A_k^l)/\norm{\v'/A_k^l} = \v'/\norm{\v'} \]
	So $\v \simeq \v'$.
\end{proof}

Let's denote $(\forall \v \in V)(\exists \v'\in V') : \v \simeq \v'$ as $V \sqsubseteq V'$.  Then, considering the discussion before the proposition, we have the following result.  Say $V \in \R^{d\times n}$ is extreme.  Also suppose that $C_V = \cone(V) = \set{\x\st A\x\leq\0}$.  Then
\[ C_V = \cone(V') \quad\Leftrightarrow\quad
	(\forall \v'\in V')A\v'\leq\0,\; V \sqsubseteq V' \]

We now have a method for testing the program.  First, we hand-craft an H-Cone $\set{\x\st A\x\leq\0}$ based on some extreme set $V$, then run our program to get a set $V'$, with the alleged property that $\cone(V') = \set{\x\st A\x\leq\0}$.  If we confirm that $\forall \v'\in V', A\v'\leq 0$ and $V \sqsubseteq V'$, then our program has succeeded.

\subsection{Farkas Lemma}
The procedure for the other direction is \textit{almost} identical, but there is a slight catch.  Call a set of row vectors \textbf{extreme} if no row is a non-negative combination of the other.  We would be able to use proposition \ref{prop:minrays} to say something similar about an extreme set of row vectors $A$, if we could say that:

\begin{Prop}\label{prop:ddcones}
	\[ \set{\x\st A\x\leq\0} = \set{\x\st A'\x\leq\0} \Leftrightarrow \cone(A^T) = \cone(A'^T) \]
\end{Prop}


To prove this proposition, we use the Farkas Lemma:

\begin{Prop}[The Farkas Lemma]\label{prop:Farkas}
	Let $U \in \R^{d\times n}$.  Precisely one of the following is true:
	\[ (\exists \t \geq \0) : \x = U\t \]
	\[ (\exists \y) : U^T\y \leq 0,\; \ip{\x}{\y} > 0 \]
\end{Prop}

\begin{proof}  That both can't be true can be seen by:
	\[ \x = U\t \quad\Rightarrow\quad \y^T\x = \y^T U\t \quad\Rightarrow\quad 0 \neq 0 \]
	To see that at least one is true we must reconsider the process of converting a V-Cone to an H-Cone.  First, we lift the V-Cone $\cone(U)$ into the following form:
	\[ A = \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*}  \]
	In the proof of the transformation, we use proposition \ref{prop:hconeproj} to transform that matrix $A$.  The remark \ref{rem:fm} after the proof of the proposition promises a sequence of matrices $Y_{d+1}, \dots, Y_{d+n}$ satisfying certain properties.  Let $Y = Y_{d+n}Y_{d+(n-1)}\dots Y_{d+1}$, then it can be said of $Y$:
	\begin{enumerate}
		\item Every element of $Y$ is non-negative.
		\item $Y$ is finite.
		\item The last $n$ columns of $YA$ is $\0$.
		\item \((\exists t_{d+1},\dots,t_{d+n})A(\x + \sum_{i=d+1}^{d+n} t_i\e_i) \leq \0
		      \Leftrightarrow (YA)\x \leq \0 \)
	\end{enumerate}
	Note that here $\x \in \R^{d+n}$.  $A$ has three blocks of rows, which can be labeled with $Z,P,N$ in a fairly obvious way.  Then, $Y$ can be broken up into three blocks of columns, so that
	\[ Y = (Y_Z \; Y_P \; Y_N) \]
	Where each of $Y_Z,Y_P,Y_N \geq \0$.  Consolidating what is known about $A$ and $Y$,
	\[ YA = (Y_Z \; Y_P \; Y_N) \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*}
		= (Y' \; \0) \]
	Here, we have let $Y' = Y_P - Y_N$.  Then it follows that
	\[ \0 = -Y_Z - Y_P(U) + Y_N(U) = -Y_Z - Y'(U) \;\Rightarrow\; Y_Z = - Y'U
		\;\Rightarrow\; Y'U \leq \0 \]
	Then it holds that, for any row $\y' \in Y'$:
	\begin{equation}\label{eq:flneg}
		\y'U \leq \0
	\end{equation}
	We also have
	\begin{equation}\label{eq:flconst}
		(\exists \t) : A \xt \leq \0 \Leftrightarrow (YA)\xt = (Y'\;\0)\xt = Y'\x \leq \0
	\end{equation}
	Note that here $\x \in \R^d$.  So, if given some $\x$, the left side of \eqref{eq:flconst} is not satisfied, then neither is the right, and there must be some row $\y' \in Y'$ such that the following holds:
	\begin{equation}\label{eq:flconstbrk} \ip{\y'}{\x} > 0 \end{equation}
	Furthermore, by the way $A$ is constructed,
	\begin{equation}\label{eq:flcone}
		(\exists \t) : A \xt \leq \0 \Leftrightarrow (\exists \t\geq\0)\; \x = U\t
	\end{equation}
	Then we conclude that, if the right side of \eqref{eq:flcone} fails, then there is a vector $\y' \in Y'$ satisfying \eqref{eq:flneg} and \eqref{eq:flconstbrk}.
\end{proof}

\subsection{Testing V-Cone $\to$ H-Cone}

Now we can prove proposition \ref{prop:ddcones}:
\[ \set{\x\st A\x\leq\0} = \set{\x\st A'\x\leq\0} \Leftrightarrow \cone(A^T) = \cone(A'^T) \]
\begin{proof}
	First suppose that $\cone(A^T) = \cone(A'^T)$.  Then there exists a non-negative matrix $B$ such that $A'^T = A^TB$.  Then $A\x \leq \0 \Rightarrow B^TA\x\leq \0 \Rightarrow A'\x\leq\0$.  Precisely the same reasoning shows that $A'\x\leq\0 \Rightarrow A\x\leq\0$, and we conclude that $\cone(A^T) = \cone(A'^T) \Rightarrow \set{\x\st A\x\leq\0} = \set{\x\st A'\x\leq\0}$.

	Next suppose that $\cone(A^T) \neq \cone(A'^T)$, that is, let $\z \in \cone(A), \z \not\in\cone(A')$.  We must show that $\set{\x\st A\x\leq\0} \neq \set{\x\st A'\x\leq\0}$.  By the Farkas Lemma, we have a $\y$ such that $\ip{\y}{\z} > 0,\; A'\y \leq \0$.  Clearly this means that $\y \in \set{\x\st A'\x\leq\0}$.  Since $\z \in \cone(A)$, there is some $(\t \geq \0): \z^T = \t^T A$.  Then if $A\y\leq\0$, we would have $\ip{\y}{\z} = \t^T A\y \leq 0 < \ip{\y}{\z}$, a contradiction.  So we conclude that $\y\not\in\set{\x\st A\x\leq\0}$.
\end{proof}

\paragraph{The Test}
\textit{Finally}, we can make a test for the transformation from V-Cone to H-Cone.  Let $A$ be an \textit{extreme} set of row vectors.  Then clearly $A^T$ is an extreme set of column vectors, and we can use propositions \ref{prop:minrays} and \ref{prop:ddcones} to say that
\[ \HC{A} = \HC{A'} \Leftrightarrow \cone(A^T) = \cone(A'^T) \Rightarrow A^T \sqsubseteq A'^T \]
Given the last implication, we can also write $A \sqsubseteq A'$, where we are now considering $A$ and $A'$ as sets of row vectors as opposed to column vectors.

Now, as before, we suppose that we have a set $V$ and $A$, where $A$ is extreme, and we know that $C := \cone(V) = \HC{A}$.  We run our program on $V$ and get a new set $A'$, and would like to know if $C = \HC{A'}$.  We have the following situation:
\begin{alignat*}{2}
	 & C = \HC{A'}    \;                  & \Rightarrow & \; A \sqsubseteq A'               \\
	 & C = \HC{A'}    \;                  & \Rightarrow & \; (\forall \v\in V) A'\v \leq \0 \\
	 & A \sqsubseteq A' \;                & \Rightarrow & \; \HC{A'} \subseteq C            \\
	 & (\forall \v\in V) A'\v \leq \0  \; & \Rightarrow & \; C \subseteq \HC{A'}
\end{alignat*}
So we can conclude that
\[ C = \HC{A'} \quad\Leftrightarrow\quad
	(\forall \v\in V)A'\v\leq\0,\; A \sqsubseteq A' \]

\subsection{Testing H-Polyhedron $\to$ V-Polyhedron}

Say we have an H-Polyhedron $P_H = \HP{A}{b}$, and wish to check that our program correctly calculates a $V'$ and $U'$ such that $P_H = \cone(U') + \conv(V')$.  Again, we shall use the notion of extremity and show that under certain circumstances we can use extreme sets to demonstrate the validity of our algorithm.  In this case, the definition of extreme is a little more complicated, but it asserts that a set $U$ is extreme as before, and that no element of another set $V$ can be expressed as a non-trival sum of a convex combination of $V$ and a non-negative linear combination of members of $U$.

\begin{Def}[Extreme Pair]{ A pair of sets $U\in\R^{d\times n}, V\in\R^{d\times p}$ is called an \textit{extreme pair} if for any $\u = U\e_k, \v = V\e_l$ the following is true:
		\begin{alignat*}{1}
			 & \t \geq \0,\; \u = U\t \Rightarrow \t = \e_k                     \\
			 & \t \geq \0, \blam \geq \0, \ip{\blam}{\1} = 1, \v = U\t + V\blam
			\Rightarrow \t = \0, \blam = \e_l
		\end{alignat*}
	}\end{Def}

Let us now consider the set $U$ in the expression $\HP{A}{b} = \cone(U) + \conv(V)$.
\begin{Prop}{\label{prop:ultz}
		Suppose that $P := \HP{A}{b} = \cone(U) + \conv(V)$.  Then
		\[ \cone(U) = \HC{A} \]
	} \end{Prop}
\begin{proof}
	We show that the following three statements are equivalent:
	\begin{enumerate}
		\item $A\r\leq\0$
		\item $(\forall \x\in P)(\forall \alpha > 0)\;\x + \alpha\r \in P$
		\item $\r \in \cone(U)$
	\end{enumerate}
	$(1 \Rightarrow 2)$. $\x\in P$ means that $A\x\leq\b$, and $A\r\leq\0$ means that $A(\x+\alpha\r) \leq A\x \leq \b$.\\
	$(\neg 1 \Rightarrow \neg 2)$.  Suppose $\ip{A_i}{\r} \geq 0$, then let $\alpha > (b_i - \ip{A_i}{\x})/\ip{A_i}{\u}$.  We have:
	\[ \ip{A_i}{\x + \alpha\u} > \ip{A_i}{\x} +
		\frac{b_i\ip{A_i}{\u} - \ip{A_i}{\x}\ip{A_i}{\u}}{\ip{A_i}{\u}} = b_i \]
	$(3 \Rightarrow 2)$.  This is essentially the definition of $\cone(U) + \conv(V)$.
	$(2 \Rightarrow 3)$.  Now for the real work.  Suppose that (2) holds, but $\r\not\in\cone(U)$.  Then by the Farkas Lemma, we have a $\y$ that satisfies $(\forall \u\in U)\,\ip{\u}{\y}\leq 0,\; \ip{\y}{\r} > 0$.  From (2) we construct a sequence: $(\x_n) = \v+n\cdot\r$.  Then it is clear that the sequence $\ip{\y}{\x_n} \to \infty$.  It is also clear that $(\forall n)\,\x_n \in P$.  We now need the following:
	\begin{itemize}
		\item A linear, real-valued function on the set $\conv(V)$ achieves its maximal value at some $\bar\v \in V$.
	\end{itemize}
	To see this is true, suppose that the linear function is given by $\ip{\y}{\cdot}$, and that $\bar\v$ is an element of $V$ such that $(\forall \v \in V)\,\ip{\y}{\bar\v} \geq \ip{\y}{\v}$.  Then, for any $\u \in \conv(V)$, $\u = \sum_{\v\in V} \lambda_v\v$ where $\sum \lambda_v = 1 \Rightarrow \lambda_v \leq 1$, and it follows
	\[\ip{\y}{\u} = \ip{\y}{\sum_{\v\in V}\lambda_v v} = \sum_{v\in V} \lambda_v\ip{\y}{\v}
		\leq \sum_{v\in V}\lambda_v\ip{\y}{\bar\v} = \ip{\y}{\bar\v} \]
	Now consider the maximum value of the function $\ip{\y}{\cdot}$ on $P$.  Since any element of $P$ can be written $\u + \v \st \u\in\cone(U),\,\v\in\conv(V)$, and $(\forall\u\in U) \ip{\y}{\u} \leq 0$, we can find the maximum value on $\conv(V)$.  However, $\ip{\y}{\cdot}$ achievs its maximal value on $\conv(V)$ at some $\bar\v\in V$, which is a contradiction with the fact that $\ip{\y}{\x_n} \to \infty$, so we conclude that $\r\in\cone(U)$.
\end{proof}

\paragraph{Remark.}  Note that $(2)$ in the proof above is independent of $A$ and $U$.  This means that the cone of a polyhedron is independent of its representation, i.e. if $\cone(U) + \conv(V) = \cone(U') + \conv(V')$, then $\cone(U) = \cone(U')$, while it is not necessarily true that $\conv(V) = \conv(V')$.  Similarly, if $\HP{A}{\b} = \HP{A'}{\b'}$, the it holds that $\HC{A} = \HC{A'}$.\\

One more quick observation to make tidier notation, and we will be ready to state the testing criteria.  Let $\Lambda$ represent a collection of convex combinations, that is, $\vec{1}^T\Lambda = \vec{1}^T$, and let $\lambda\geq\0,\,\1^T\lambda = 1$ be a typical convex combinator.  Then $\Lambda\lambda = \lambda'$ where $\lambda'\geq\0,\,\1^T\lambda'=1$.  That $\lambda'\geq\0$ is clear, then just note that $\1^T\lambda' = \1^T\Lambda\lambda = \1^T\lambda = 1$.  In words, \textit{a convex combination of convex combinations is yet again a convex combination}.

\begin{Prop}{\label{prop:hpolytest}
		Suppose that there is an extreme pair $U,V$ such that $\cone(U) + \conv(V) = \HP{A}{b}$.  Denote this Polyhedron $P$.  Then the following are equivalent:
		\begin{enumerate}
			\item $P = \cone(U') + \conv(V')$
			\item $U \sqsubseteq U',\; V \subseteq V',\;
				      (\forall \u'\in U',\v'\in V') A\u'\leq\0, A\v'\leq\b$
		\end{enumerate}
	}\end{Prop}

\begin{proof}
	$(2 \Rightarrow 1)$.  There's not too much to say about this direction, it's mostly just collecting some straightforward observations and results.
	\begin{itemize}
		\item[(a)] $U \sqsubseteq U' \Rightarrow \cone(U) \subseteq \cone(U')$
		\item[(b)] $V \subseteq V' \Rightarrow \conv(V) \subseteq \conv(V')$
		\item[(c)] (a) + (b) $\Rightarrow \cone(U)+\conv(V) \subseteq \cone(U') + \conv(V')$
		\item[(d)] $(\forall \u'\in U') A\u' \leq \0 \Rightarrow \cone(U') \subseteq \cone(U)$
		\item[(e)] $(\forall \v'\in U') A\v' \leq \0 \Rightarrow \conv(V') \subseteq P$
		\item[(f)] (d) + (e) $\Rightarrow \cone(U') + \conv(V') \subseteq P + \cone(U) = P$
		\item (c) + (f) $\Rightarrow (2 \Rightarrow 1)$
	\end{itemize}

	$(1 \Rightarrow 2)$.  This direction is a little more interesting.  First we observe:
	\[ \cone(U) = \HC{A} = \cone(U') \Rightarrow U \sqsubseteq U' \]
	The equalities follow proposition \ref{prop:ultz}, and the implication from proposition \ref{prop:minrays}.  Note that the extremeness of $U$ and the Farkas lemma are both used here.  Since we know that $\cone(U) = \cone(U')$, we also know that $\cone(U') + \conv(V') = \cone(U) + \conv(V')$.  Next, we consider $V$ and exploit its extremeness.  Since $P = \cone(U) + \conv(V')$, each $\v'\in V'$ can be written $U\t + V\blam$, where $\t \geq \0$ and $\blam$ is a convex combinator.  We combine these into matrices $T$ and $\Lambda$, so $V' = UT + V\Lambda$.  But it is also true that every $\v\in V$ can be written as
	\[ \v = U\t + V'\blam = U\t + (UT + V\Lambda)\blam = U\t' + V\blam' \]
	Where $\t'\geq\0$, and $\blam'$ is a convex combinator.  Because $U,V$ is an extreme pair, we have that $\t'=\0$, and $\blam = \e_k$ for some $k$.  Because $U$ is extreme, it does not contain $\0$, and so $\t = \0$.  This puts us at $\v = V'\blam = V\Lambda\blam = V\blam'$, and $\blam' = \e_k$.  In order that $\blam' = \e_k$, for every column of $\Lambda$ corresponding to a positive entry in $\blam$, only one row may contain a positive entry, and that entry must be $1$.  Then instead of $\blam$, use instead $\e_l$ where $\Lambda_k^l = 1$.  Then $\Lambda\blam = \Lambda\e_l$, so $V\Lambda\blam = V\Lambda\e_l = V'\e_l=\v'$ where $\v'\in V'$.  Then $\v \in V'$.

	That $(\forall \v'\in V')A\v'\leq\b$ is obvious, and that $(\forall\u'\in U') A\u'\leq\0$ is the subject of proposition \ref{prop:ultz}.
\end{proof}

\paragraph{The Test.}  To test our program, we \textit{simply} create Polyhedron $P =$ $\HP{A}{b}$ $= \cone(U) + \conv(V)$ where $(U,V)$ is an extreme pair, run our program on $(A,b)$ to get some new $(V',U')$.  Then, we check that $A\v' \leq \b$, $A\u'\leq\0$, $U\sqsubseteq U'$, and $V\subseteq V'$.

\subsection{Testing V-Polyhedron $\to$ H-Polyhedron}
Now we suppose we have a V-Polyhedron $P = \cone(U) + \conv(V)$, and would like to test the program which returns a matrix-vector pair $A',\b'$ where supposedly $P = \HP{A'}{\b'}$.  Again, we will start off with a pair $A,\b$ where we know that $P = \HP{A}{\b}$, where $A,\b$ satisfy some nice properties, and use those properties to test if $P = \HP{A'}{\b'}$.  In order to demonstrate these properties, the Farkas Lemma will be used, but in different forms.  We want to use proposition \ref{prop:ddcones}, but first we have to check:

\begin{Prop}{\label{prop:homog}
		The following statements are equivalent:
		\begin{enumerate}
			\item $\HP{A}{\b} = \HP{A'}{\b'}$
			\item $\set{\xx \big| \pmb -1 & \0 \\ -\b & A \pme \xx \leq \0} =
				      \set{\xx \big| \pmb -1 & \0 \\ -\b' & A' \pme \xx \leq \0}$
		\end{enumerate}
	}\end{Prop}

\begin{proof}
	$(2 \Rightarrow 1)$.  Just set $x_0 = 1$, and move $\b,\b'$ to the right side of the inequalities.

	$(\neg 2 \Rightarrow \neg 1)$.  Suppose that:
	\[ \pmb -1 & \0 \\ -\b & A \pme \xx \leq \0,\quad
		\pmb -1 & \0 \\ -\b' & A' \pme \xx \not\leq \0 \]
	Observe that, by the way these sets are constructed, $x_0 \geq 0$.  If $x_0 = 0$, then we have $\HC{A} \neq \HC{A'}$, which, by the remark following proposition \ref{prop:ultz} means that $\HP{A}{\b} \neq \HP{A'}{\b'}$.  If $x_0 > 0$, then we have:
	\[ A\x \leq x_0\b,\;A'\x\not\leq x_0\b' \Rightarrow A(\x/x_0)\leq\b,\;A'(\x/x_0)\not\leq\b' \]
	So $\HP{A}{\b} \neq \HP{A'}{\b'}$.
\end{proof}

Now, combining the results of propositions \ref{prop:ddcones} and \ref{prop:homog}, we have the following result:

\begin{Prop}{\label{prop:ddpoly}
		The following two statement are equivalent:
		\begin{enumerate}
			\item $\HP{A}{\b} = \HP{A'}{\b'}$
			\item $\cone \pmb -\b^T & -1 \\ A^T & \0 \pme = \cone \pmb -\b'^T & -1 \\ A'^T & \0 \pme$
		\end{enumerate}
	}\end{Prop}

\subsection{Extreme H-Polyhedra Pairs}
\begin{Def}[Extreme Pair]{
		A pair $A,\b$ is called \textbf{extreme} if $\HP{A}{\b}$ is non-empty, and
		\[ \t \geq \0,\, \t^T(A,b) = (A_i,b_i) \Rightarrow [\t \neq \0 \Rightarrow \t = \e_i] \]
	}\end{Def}

Of course, we want to say that if $P = \HP{A}{\b}$ where $(A,\b)$ is an extreme pair, and $P = \HP{A'}{\b'}$, then, by proposition \ref{prop:ddpoly}, $(A,\b) \sqsubseteq (A',\b')$.  The catch is that the cones in proposition \ref{prop:ddpoly} have a strange form.  What we want to be true turns out to be so, but before we can prove this fact, we need a property of extreme pairs, which requires a new form of the Farkas Lemma.

\subsection{Farkas Lemma: Round 2}

Let us restate the conclusion of the Farkas Lemma:
\newcommand{\xor}{\;\Leftrightarrow\;\neg}
\[ \exists \t\geq\0 \st U\t = \x \xor \exists \y\st \y^TU\leq\0,\, \y^T\x > 0 \]
If we let $U = (A,-A,I)$, and  we get a new form:
\[ \exists \t \geq\0 \st (A,-A,I)\t = \x \xor \exists \y\st \y^T(A,-A,I)\leq\0,\, \y^T\x > 0 \]
Then breaking apart $\t = (\t_P,\t_N,\t_I)$, we have
\[ (A,-A,I)\begin{pmatrix}\t_P\\ \t_N\\ \t_I)\end{pmatrix} = \x \Rightarrow
	A(\t_P - \t_N) = \x - \t_I \]
If we let $\t_P - \t_N = \z$, then $\z$ is no longer constrained by $\t \geq\0$, and we have that $A\z \leq \x$.  Since $\y^T A \leq \0$ and $-\y^T A\leq \0$, it must be that $\y^T A = \0$.  Combining these results, relabeling $\x$ as $\b$ and $\z$ as $\x$, and $\y$ as $-\y$, we see a new form of Farkas Lemma:
\begin{equation} \label{eq:FL2}
	\exists \x \st A\x \leq \b \xor \exists \y\geq\0 \st \y^TA = \0,\, \y^T\b < 0
\end{equation}
This form tells us that an H-Polyhedron is non-empty, or we can create an inequality that is impossible to solve from it's matrix.  The next form shows a similar result, but this time it is for a specific $\x$, not implying the emptyness of the Polyhedra, just the constraints' failure to be satisfied at a specific point.

First observe that (using \eqref{eq:FL2})
\[ A\x \not\leq \b \Leftrightarrow \neg \exists \z\st
	\pmb A\\I\\-I\pme \z \leq \pmb \b\\ \x\\ -\x \pme \Leftrightarrow
	\exists \y\geq\0\st \y^T\pmb A\\I\\-I\pme =\0,\, \y^T\pmb \b\\ \x\\ -\x \pme < 0\]
Splitting up $\y$ into components like we did before with $\t$, we can rewrite this as
\begin{equation} \label{eq:FL3}
	A\x \not\leq \b \Leftrightarrow \exists \y\st \y^T A = \w,\, \y^T \b < \w^T\b
\end{equation}

We can now prove some useful properties of extreme pairs.

\begin{Prop}{\label{prop:hextpair}
		Let $A,\b$ be an extreme pair.  Then the following holds:
		\begin{alignat}{6}
			\t\geq\0,\,\t^T A \,                      & =           & \, \0  \,         & \Rightarrow & \, [\t   & \neq & \, \0 \,
			                                          & \Rightarrow & \, \ip{\t}{\b} \, & >           & \, 0 ]                       \\
			\label{hextpairprop} \t\geq\0,\,\t^T A \, & =           & \, A_i \,         & \Rightarrow & \, [\t   & \neq & \, \e_i \,
			                                          & \Rightarrow & \, \ip{\t}{\b} \, & >           & \, b_i ]
		\end{alignat}
	}\end{Prop}
\begin{proof}
	Suppose that $\t^T A = \0,\, \t\neq\0$.  Next suppose that $\t^T\b = 0$.  Then $(\t + \e_i)(A,b) = (A_i,b_i)$, but $\t+\e_i \neq \e_i$, a contradiction.  Next suppose that ${\t^T\b < 0}$.  Then we have that $\exists \t\geq\0,\,\t^T A = \0,\,\t^T \b < 0$, which by \eqref{eq:FL2} means that $\HP{A}{b}$ is empty, a contradiction.  So the first property is proven.

	Now suppose that $\t^T A = A_i, \t\neq\e_i$.  Then we know that $\t^T \b \neq b_i$, but if $\t^T\b < 0$, we'd have that $(\t - \e_i)^T A = \0, (\t-\e_i)^T\b < 0$, contradicting the first property.
\end{proof}

We are now prepared to prove the following proposition.

\begin{Prop}{\label{prop:ddhext}
		Suppose that $\HP{A}{\b} = \HP{A'}{\b'}$, where $(A,\b)$ is an extreme pair.  Then $(A,\b) \sqsubseteq (A',\b')$.
	}\end{Prop}

\begin{proof}
	It suffices to show that $\pmb -\b^T & -1 \\ A^T & \0 \pme$ is extreme, for then:
	\[\pmb -\b^T & -1 \\ A^T & \0 \pme \sqsubseteq \pmb -\b'^T & -1 \\ A'^T & \0 \pme \Rightarrow
		\pmb -\b^T \\ A^T \pme \sqsubseteq \pmb -\b'^T \\ A'^T \pme \Rightarrow
		(A,\b) \sqsubseteq (A',\b')
	\]
	So, suppose that $(\t,t) \geq \0$, $\pmb -\b^T & -1 \\ A^T & \0 \pme(\t,t) = \pmb -b_i \\ A^T_i\pme$.  We must show that $\t = \e_i$, $t = 0$.  Suppose that it's not.  Then we have $\t^T A = A_i$, and by \eqref{hextpairprop} $\t^T-\b < b_i$.  Since $-t \leq 0$, $\t^T-\b - t < b_i$, a contradiction.  So we have shown that $\t = \e_i$, in which case $t = 0$, and the proposition follows.
\end{proof}

\subsection{The Test}

Let $AU \leq \b$ be shorthand for $(\forall \u\in U) A\u \leq \b$.

Suppose that we have a $(U,V)$ and $(A,\b)$ such that $P := \cone(U) + \conv(V) = \HP{A}{\b}$, and $(A,\b)$ is an extreme pair.  We run our program and get a new pair $(A',\b')$.  Denote $P' := \HP{A'}{\b'}$.  We would like to verify that $P = P'$.  We have the following:
\begin{enumerate}
	\item $A'U\leq\0,\, A'V\leq\b' \Rightarrow P \subseteq P'$
	\item $(A,\b) \sqsubseteq (A',\b') \Rightarrow P' \subseteq P$
	\item $P = P' \Rightarrow A'U\leq\0,\, A'V\leq\b'$
	\item $P = P' \Rightarrow (A,\b) \sqsubseteq (A',\b')$
\end{enumerate}

So we conclude that
\[ P = P' \Leftrightarrow A'U\leq\0,\,A'V\leq\b',\,A\sqsubseteq A' \]
To test our program, we just verify the right side of the equivalence, which is fairly straightforward.

\subsection{\filename{test\_functions.h}}

The following types are defined for running tests of the different algorithms.  They are expected to be given a descriptive name, the object on which the test will be run, and a \lsti{key} with which the result of the test will be compared.  The \list{key} object is one of the objects described above.
\lsthconetestcasea
\lstvconetestcasea
\lsthpolytestcaseb
\lstvpolytestcaseb

\subsection{\filename{test\_functions.cpp}}

The dot-product and norm (in terms of dot product).
\lstoperator
\lstnorm

\lsti{approximately_zero} is used during tests to avoid issues involving floating point rounding errors.  For example, \lsti{1/6.0 * 2.5 - 5/12.0 == 0} will give \lsti{false}, while \lsti{approximately_zero(1/6.0 * 2.5 - 5/12.0)} will return \lsti{true}.  Test cases are used where intermediate calculations don't depend on such high accuracy, and these discrepencies can be ignored.

\lsti{approximately_zero(c) == true} will be denoted $\mli{c} \approx 0$.
\lstapproximatelyzeroa

%Tests $\mli{c} < 0 \lor \mli{c} \approx 0$.
Tests $c < 0 \lor c \approx 0$.
\lstapproximatelyltzero

%Tests $\norm{\mli{v}} \approx 0$.  This will be denoted $\mli{v} \approx \0$.
Tests $\norm{\v} \approx 0$.  This will be denoted $\v \approx \0$.
\lstapproximatelyzerob

%Tests $\mli{l}/\norm{\mli{l}} - \mli{r}/\norm{\mli{r}} \approx \0 $.  This will be denoted $\mli{l} \simeq \mli{r}$.
Tests $\u/\norm{\u} - \v/\norm{\v} \approx \0 $.  This will be denoted $\u \simeq \v$.
\lstisequivalent

%Tests $\mli{l} - \mli{r} \approx \0$.  This will be denoted $\mli{l} \approx \mli{r}$.
Tests $\u - \v \approx \0$.  This will be denoted $\u \approx \v$.
\lstisequal

%Tests $(\exists \mli{u} \in \mli{Matrix M}) \st \mli{v} \simeq \mli{u}$.
Tests $(\exists \u \in U) \st \v \simeq \u$.
\lsthasequivalentmember

%Tests $(\exists \mli{u} \in \mli{Matrix M}) \st \mli{v} \approx \mli{u}$.
Tests $(\exists \u \in U) \st \v \approx \u$.
\lsthasequalmember

%Tests $(\forall \mli{ray} \in \mli{Matrix vcone}) (\exists \mli{g} \in \mli{Matrix generators}) \st \mli{v} \simeq \mli{u}$.
Tests $(\forall v \in V)(\exists \u \in U) \st \v \simeq \u$.  This will be denoted $V \sqsubseteq U$.
\lstsubsetmodeq

%Tests $(\forall \mli{ray} \in \mli{Matrix vcone}) (\exists \mli{g} \in \mli{Matrix generators}) \st \mli{v} \approx \mli{u}$.
Tests $(\forall v \in V)(\exists \u \in U) \st \v \approx \u$.  This will be denoted $V \subseteq U$.
\lstsubset

Given a \mli{Vector constraint} and \mli{Vector ray}, tests if \\
\lsti{approximately_lt_zero(ray * constraint)}.  Note that if the constraint is of the form $\ip{A_i}{\v} \leq b$ for some value $b$, then this still works, because the dot product function only takes the first $d$ values of each vector.
\lstraysatisfieda

%Test $(\forall \mli{cv} \in \mli{Matrix constraints})\,\mli{ray_satisfied(ray, cv)}$
Test $A\v \leq \0$
\lstraysatisfiedb

%Test 
%\begin{align*}
%&(\forall \mli{ray} \in \mli{Matrix rays})(\forall \mli{cv} \in \mli{Matrix constraints})\\
%&\quad\mli{ray_satisfied(ray, cv)}
%\end{align*}

Test $(\forall \v) A\v \leq \0$
\lstrayssatisfied

Test $\ip{A_i}{\v} \leq b_i$
\lstvecsatisfieda

Test $A\v \leq \b$
\lstvecsatisfiedb

Test $(\forall \v) A\v \leq \b$
\lstvecssatisfied

Given an H-Cone $C_H = \set{\x\st A\x\leq\0} = \cone(U)$ where $U$ is minimal, and an alternative representation $U'$, determines if $C_H = \cone(U')$.

Similarly, given a V-Cone $C_U = \cone(U) = \set{\x\st A\x\leq\0}$ where $A$ is minimal, and an alternative representation $A'$, determines if \\
$C_U = \set{\x\st A'\x\leq\0}$.
\lstequivalentconerep

Given an H-Polytope $P_H = \set{\x\st A\x\leq\b} = \cone(U) + \conv(V)$ where $U$ and $V$ are minimal, and an alternative representation $(U',V')$, determines if $P_H = \cone(U') + \conv(V')$.
\lstequivalenthpolyrep

Given a V-Polytope $P_V = \cone(U) + \conv(V) = \set{\x\st A\x\leq\b}$ where $A$ is minimal, and an alternative representation $A'$, determines if $P_V = \set{\x\st A'\x\leq\0}$.
\lstequivalentvpolyrep

%\lsthconetestcaseb
%\lstvconetestcaseb
%\lsthpolytestcasea
%\lstvpolytestcasea


