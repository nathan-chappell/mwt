\chapter{C++ Implementation}
%TODO update the content below, migrate commentary, input usage file...

The above transformation have been implemented in C++.  Program \lsti{main.cpp} takes on argument specifying the type of input object.  It reads the description of the object from standard input, and writes the result of the implied transformation to standard output.  If no arguments are supplied, then a \lsti{usage} message is given.  The \lsti{usage} message, which also contains the input format for the objects, is:

\VerbatimInput{../../usage.txt}

The files pertaining to the implementation will be discussed in the following sections, but here is a table showing the include dependencies followed by a short summary of the files. \\

\begin{tabular}{|l|l|}
\hline
file & includes \\
\hline
\filename{linear\_algebra.h} & \\
\filename{fourier\_motzkin.h} & \filename{linear\_algebra.h} \\
\filename{polyhedra.h} &        \filename{fourier\_motzkin.h} \\
\filename{main.cpp} &           \filename{polyhedra.h} \\
\filename{test\_functions.h} &  \filename{linear\_alebra.h} \\
\filename{test.cpp} &           \filename{test\_functions.h}, \filename{polyhedra.h}\\
\hline
\end{tabular}\\

\vspace{1em}

Here is a very brief summary of the files mentioned in the above table, more details are given in sequent sections.

\begin{itemize}
  \item \texttt{linear\_algebra.h}\\
    Types \lsti{Vector} and \lsti{Matrix}, and some basic functionality for them
  \item \texttt{fourier\_motzkin.h} \\
    Fourier Motzkin elimination, \MWT for cones
  \item \texttt{polyhedra.\{cpp,h\}} \\
    Transforms between polytopes and polyhedra, \MWT
  \item \texttt{test\_functions.h} \\
    Types and functions for testing the algorithms, e.g. if an h-polyhedra contains some points
  \item \texttt{test.cpp} \\
    Test cases for functions from \filename{test\_functions.h} and algorithms for \MWT
\end{itemize}

\section{Code}

The relevant code will be displayed with commentary below.  Some of the code relating to C{++} specific technicalities and I/O is ommitted.

\subsection{\filename{linear\_algebra.h}}
The types \lsti{Vector} and \lsti{Vatrix} are used in the representation of polyhedra.  The \lsti{std::valarray} template is used because it has built-in vector-space operations (sum and scaling).  \lsti{std::vector}, is used, however other sequence containers could be used.
\lsttdVecs

The \lsti{class Matrix} implements a subset of what a \textit{C++ Container} should.  It is the primary type for representing polyhedra, and directly represents Cones, as well as H-Polyhedra.  The interface is designed to enforce the following invariant:
\[ \invariant{(\forall \mli{v} \in \mli{vectors})\, \mli{v.size() == d}} \]
  The \textit{factory} function \lsti{read_Matrix} is provided to read a \lsti{Matrix} from an \lsti{istream}.  It is necessary because the value of \lsti{d} can't be known before reading some of the stream.
\lstMatrix

The \lsti{struct VPoly} gather two \lsti{Matrix}s needed to represent a V-Polyhedron.  The \lsti{Matrix U} corresponds to the rays that generate the cone, and the \lsti{Matrix V} corresponds to the points, i.e. 
  \[ \mli{Vpoly vpoly} = \set{p + q \st p \in \cone(\mli{vpoly.U}),\, q \in \conv( \mli{vpoly.V} )} \]
\lstVPoly

The \lsti{class input_error} is thrown to indicate an invalid input to the program, and provide some clue as to why it failed.  Here are two command line examples:
\VerbatimInput{../../bad_usage.txt}

\lstinputerror

\lsti{operator>>} and \lsti{operator<<} implement the input format described in \\\filename{usage.txt}.
\lstissV
\lstossV

\lsti{usage()} outputs the usage message shown above.
\lstusage

\subsection{\filename{linear\_algebra.cpp}}
\lsti{e_k} creates the canonical basis \lsti{Vector} $\e_k \in \R^d$.
\lstek

\lsti{concatentate} takes the \lsti{Vector}s $\mli{l} \in \R^{\mli{l.size()}}$ and $\mli{r} \in \R^{\mli{r.size()}}$ and \lsti{return}s the \lsti{Vector} $(\mli{l,r}) \in \R^{\mli{l.size() + r.size()}}$
\lstconcatenate

\lsti{get_column} \lsti{return}s the \lsti{k}-th column of the \lsti{Matrix M}.  Note that while a \lsti{Matrix} may logically represent either a collection of row or column \lsti{Vector}s, \lsti{get_column} is only used in the function \lsti{transpose}, where this distinction is unimportant.
\lstgetcolumn

\lsti{transpose} \lsti{return}s the transpose of \lsti{Matrix M}.
\lsttranspose

An \lsti{slice} object can be used to conveniently obtain a subset of an \lsti{valarray}.  \lsti{slice_matrix} \lsti{return}s the \lsti{Matrix} obtained by applying the \lsti{slice s} to each \lsti{Vector} of the \lsti{Matrix}.
\lstslicematrix

\subsection{\filename{fourier\_motzkin.h}}

\lsti{Lift} is a function pointer \lsti{typedef} that is used in a generic cone-transformation function.
\lstLift

\subsection{\filename{fourier\_motzkin.cpp}}

A \lsti{slice} object is determined by three fields: \lsti{start}, \lsti{size}, and \lsti{stride}, and implicitly represents all indices of the form:
\[ \sum_{0 \leq k < \mli{size}} \mli{start} + k\cdot\mli{stride} \]
Therefore:
\[ i \in \mli{slice} \Leftrightarrow i - \mli{start} \equiv 0 \mod(\mli{stride}),
                           \quad \mli{start} \leq i \leq \mli{start} + {\mli{stride}}\cdot\mli{size} \]
\lstindexinslice

\lsti{fourier_motzkin} takes a \lsti{Matrix M} and a coordinate \lsti{k} and creates the set which either corresponds to a projection of an H-Cone (without actually doing the projection), or the intersection of a V-Cone with a coordinate-hyperplane.
\lstfouriermotzkin

The lines:
\lstFMEPart
Partition \lsti{M} into logical sets $Z,P,N$ that satisfy the following:\\

\begin{tabular}{|l|l|l|}
  \hline
set & range & property \\
  \hline
  $Z$ & [\lsti{M.begin()}, \lsti{z_end} $)$ & 
      \lsti{it} $\in Z \Leftrightarrow$ \lsti{(*it)[k]} $ = 0$ \\
  \hline
  $P$ & [\lsti{z_end}, \lsti{p_end} ) & 
      \lsti{it} $\in P \Leftrightarrow$ \lsti{(*it)[k]} $ > 0$ \\
  \hline
  $N$ & [\lsti{p_end}, \lsti{M.end()}) & 
      \lsti{it} $\in N \Leftrightarrow$ \lsti{(*it)[k]} $ < 0$ \\
  \hline
\end{tabular}\\

The line:
\lstFMEMove
Moves $Z$ into the result.  The lines:
\lstFMEConvolute
Convolutes the vectors in the way described in Propositions \ref{prop:hconeproj} and \ref{prop:Hintset} (concerning projecting an H-Cone and intersecting a V-Cone with a coordinate-hyperplane), and push them into the result \lsti{Matrix}.  In particular, it creates the sets which correspond to
\[ \Bik B_j - \Bjk B_i \st i \in P,\, j \in N \\ \]

\lsti{sliced_fourier_motzkin} applies \lsti{fourier_motzkin} to \lsti{Matrix M} for each $k \not\in \mli{slice s}$, then slices the resulting \lsti{Matrix} using \lsti{slice_matrix} and \lsti{s}.  This is the realization of the algorithms indicated by the proofs of either direction of the {\MWT} for cones.
\lstslicedfouriermotzkin

When transforming an H-Cone to a V-Cone, it first must be written as a V-Cone of a new matrix, then it is intersected with coordinate-hyperplanes and projected.  Similarly, when a V-Cone is transformed into an H-Cone, it must be written as and H-Cone of a new matrix then projected with coordinate-projections.  The transformations are described in \eqref{eq:Alift} and \eqref{eq:Ulift}, and summarized here:
\[
  A \to \begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*} \quad
  U \to \begin{pmatrix*}[r] \0 & I & -I \\ I & A & -A \end{pmatrix*}
\]
Note that the tranformation of $U$ can be written:
\[ U \to \begin{pmatrix*}[r] \0 & I \\ I & A \\ -I & -A \end{pmatrix*}^T \]

Remembering that a \lsti{Matrix} is either a collection of row \textit{or} column \lsti{Vector}s, it is not surprising that these two transformations can be written as one function of a \lsti{Matrix} and some coefficients.  In \lsti{generalizedlift}, the coefficients are given as an \lsti{array<double, 5> C}, so the overall transformation can be illustrated as:
\newcommand{\CA}[1]{\mli{C[#1]}}
\[ \mli{Matrix M} \to 
    \begin{pmatrix*}[r] 
      \0 & \CA{0}I \\ 
      \CA{1}I & \CA{2}\mli{M} \\ 
      \CA{3}I & \CA{4}\mli{M} 
    \end{pmatrix*} \]
Where \lsti{Matrix M} is a collection of row \lsti{Vector}s, or
\[ \mli{Matrix M} \to 
  \begin{pmatrix*}[r] 
    \0 & \CA{1}I & \CA{3}I \\ 
    \CA{0}I & \CA{2}\mli{M} & \CA{4}\mli{M} 
  \end{pmatrix*} \]
Where \lsti{Matrix M} is a collection of column \lsti{Vector}s.
\lstgeneralizedlift

\lstliftvcone
\lstlifthcone
\lstconetransform
\lstvconetohcone
\lsthconetovcone

\subsection{\filename{polyhedra.cpp}}
\lsthpolytohcone
\lsthconetohpoly
\lstvpolytovcone
\lstnormalizedP
\lstvconetovpoly
\lsthpolytovpoly
\lstvpolytohpoly

\subsection{\filename{test\_functions.h}}
\lsthconetestcasea
\lstvconetestcasea
\lsthpolytestcaseb
\lstvpolytestcaseb

\subsection{\filename{test\_functions.cpp}}
\lstoperator
\lstnorm
\lstapproximatelyzeroa
\lstapproximatelyltzero
\lstapproximatelyzerob
\lstisequivalent
\lstisequal
\lsthasequivalentmember
\lsthasequalmember
\lstsubsetmodeq
\lstsubset
\lstraysatisfieda
\lstraysatisfiedb
\lstrayssatisfied
\lstvecsatisfieda
\lstvecsatisfiedb
\lstvecssatisfied
\lstequivalentconerep
\lstequivalenthpolyrep
\lstequivalentvpolyrep
\lsthconetestcaseb
\lstvconetestcaseb
\lsthpolytestcasea
\lstvpolytestcasea


%\section{\texttt{include/hcone.h, src/hcone.cpp}}
%\lstinputlisting{\cppSourceDir/include/hcone.h}
%\texttt{hcone.h} and \texttt{hcone.cpp} implement the transformation from H-Cone to V-Cone.
%
%\lstLiftHcone
%Takes a \texttt{Matrix} representing an H-Cone and creates the new matrix
%  \[ \set{\eAj, \neAj, \zei, 1 \leq j \leq d,\, 1 \leq i \leq m} \]
%where $A$ represents \texttt{hcone}.  This operation is justified by {\Hlift}.
%
%\lstIntersectVCone
%Here the tools from \texttt{common.h} are used to implement the algorithm described in proposition \ref{prop:Hintset}, where a V-Cone is sequentially intersected with coordinate-hyperplanes.  The result of these intersections is the projected to the original space.  These operations are justified by {\Hint} and {\Hproj}.
%
%\lstHconeToVcone
%This function does a sanity check and then return the transformed \texttt{hcone}.\\
%
%\section{\texttt{include/vcone.h, src/vcone.cpp}}
%\lstinputlisting{\cppSourceDir/include/vcone.h}
%\texttt{vcone.h} and \texttt{vcone.cpp} implement the transformation from V-Cone to H-Cone.
%
%\lstLiftVcone
%Takes a \texttt{Matrix} representing an V-Cone and creates the new matrix
%  \[\begin{pmatrix*}[r] \0 & -I \\ I & -U \\ -I & U \end{pmatrix*} \]
%where $U$ represents \texttt{vcone}.  This operation is justified by {\Vlift}.
%
%\lstProjectHCone
%Here the tools from \texttt{common.h} are used to implement the algorithm described in proposition \ref{prop:hconeproj}, where an H-Cone is sequentially projected down to coordinate-axis.  This result is then projected to the original space, i.e. the first $d$ coordinates are taken from each \texttt{Vector} in the \texttt{Matrix}.  These operations are justified by {\Vproj} and proposition \ref{prop:hconezero}.
%
%\lstVconeToHcone
%This function does a sanity check and then return the transformed \texttt{hcone}.\\
%
%\section{\texttt{include/polyhedra.h, src/polyhedra.cpp}}
%\lstinputlisting{\cppSourceDir/include/polyhedra.h}
%\texttt{vcone.h} and \texttt{vcone.cpp} implement the reductions from Polyhedra to Cones.
%
%\lstProjectZero
%Using the \lsti{std::slice} object, the first coordinate of each \lsti{Vector} is dropped from the \lsti{Matrix}.
%
%\lstNormalizeP
%Creates the set $V$ in \eqref{eq:cvtopv}.  Note that the operation $U^i/\Uiz$ is only done if $\Uiz$ is not already $1$
%
%\lstHpolyToHCone
%Each \lsti{Vector} is supposed to be of the form $(A_i,b)$, expressing the constraint $\ip{A_i}{\x} \leq b$.  $b$ is moved to the first coordinate, and negated to transform 
%\[ [A|b] \to [-b|A] \]
%
%\lstHconeToHPoly
%This is the inverse to \lsti{hcone_to_hpoly}:
%\[ [-b|A] \to [A|b] \]
%
%\lstVpolyToVCone
%\lsti{d} must be increased for operations which depend on it to function correctly.  Then conducts the transform:
%\[ \cone(U) + \conv(V) \to \cone\lcone \]
%
%\lstVconeToVPoly
%This implements the tranformation justified by \eqref{eq:cvtopv}, returning the result of 
%\[ \text{\lsti{vcone}} \cap \set{\x \st \ip{\e_0}{\x} = 1} \]
%
%\lstHpolyToVPoly
%\lstVpolyToHPoly
%Using the other functions in the file, these implement the described transformations.
%
